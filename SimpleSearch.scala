/* 【文字と文字列】

 * Scala において、文字や文字列は1種のデータなので、数値と同じように扱うことができる。
 * 文字列は、 String という型を用いて文字列を表現している。

 * Scala では、文字列は "abcde" のように、ダブルクォーテーションで囲って表現する。
   scala> "abcde"
   res0: String = abcde

 * Scala の文字列は、コレクションである Seq 型と同じように添字をつけることで文字を取り出すことができる。
   scala> "abcde"(0)
   res1: Char = a

   このように、() で添字の 0 を与えてやると最初の文字である a を取り出すことができる。
   Char は文字の型で、文字を意味する英単語 Character の略である。
   Char は、 2バイト(16ビット)のデータで、Unicode というエンコード(2進数の数値を文字に対応させる方法)で表現された文字となっている。

 * 「文字」は、1 文字をシングルクォーテーションで囲むことも可能。
  scala> 'a'
  res2: Char = a

 * ダブルクォーテーションで入力した場合は、文字ではなく文字列になってしまう。
  scala> "a"
  res3>: String = a

*/


/* 【文字列検索について】

 * 文字列検索には、「索引型検索」と「非索引型検索」の二通りのやり方が存在する。

 * ■ 索引型検索
   文章の中からあらかじめ単語の文字列を抜き出して、その単語ごとに索引を作っておく検索方法。
   例えば、ある本の索引で「プログラミング」を調べると、 10P, 122p, 212p と書いてあったとすれば、10ページを開くとプログラミングについて書いてあるというような利用方法。
   この本では、あらかじめ単語の内容が本のどこに存在するかを索引に記録して、本につけてあるわけである。
   実際に索引をコンピューターで行う場合は、単語ごとに、対象の文章の中でどれぐらいその単語が利用されているかや、出現位置などに応じてスコアが計算される。
   そして、そのスコアに応じて膨大な文書群の中から適切な文章を探し出せるようになっている。
   Google などの Web 検索では、この索引型検索を利用している。
   索引のことを英語で index という。

   ■ 非索引型検索
   索引によって検索するのではなく、与えられた文字の情報のみを用いて検索する。
   索引型検索と異なり、検索するたびに対象のデータを全て走査するため、膨大な文章群から検索する場合には時間がかかる。
   対象のデータが少ない場合には索引を作成しなくてよいため、高速に検索でき、かつ文書が変更されるたびに索引を更新しなくて良いというメリットがある。
   エディタ内の文字検索や、ソフトウェアや Web ページ内の検索によく用いられている。

   * 文字列検索アルゴリズムのオーダー
   「文章」の文字列を n 、「パターン」の文字数を m としたときに、 n × m 回文字比較をする必要がある。
   オーダー記法で記述すると、 O(nm) のオーダーのアルゴリズムとなる。

  */


  /* 【for と while】

   * Scala には、ループを記述するための文法である for 式と while 式がある。
   * for も if と同様に、「文」ではなく「式」であり、値を返すことができる。

   ■ for 式
     for (i <- 0 to 10) { println(i) } のように書くことができる。

     JavaScript の for 文では、初期化式や条件式、変化式などを記述する必要があったが、Scala では、0 から 10 のループに関しては to という記述を用いる。
     i はループ毎の変数の値が入っている。

   ■ while 式
     var i = 0
     while (i <= 10) { println(i); i = i + 1 }

     while 式は、while の後ろの () の中の値が true であればずっとループを続ける。
     ここでは、変数i を var で宣言し、それをループごとに 1 ずつ増やしていく。
     そして、条件式が i <= 10 (i が 10 以下) の間ループをするように記述されている。

     Scala で命令文は ; を入れることで、1行で何回も命令文を記述できる。

     while 式には、 do-while 形式で記述する方法もある。
      var i = 0
      do { println(i); i = i + 1 } while ( i <= 10 )

     実行後に while の判定をする形式での実装も可能。


  */


object SimpleSearch extends App {
  val text = "カワカドカドカドドワンゴカドカドンゴドワドワンゴドワカワカドンゴドワ".toSeq
  val pattern = "ドワンゴ".toSeq
  val matchIndexes = Seq()

  println(s"出現場所: ${matchIndexes}")
}

/* 【解説】
 * 検索対象の「文書」が text で、検索する「パターン」を pattern とする。
   これらの定数にそれぞれ toSeq を呼び出すことで、Seq[Char]型に変換しておく。
   答えは、matchIndexes とし、まずここでは仮の答えの殻のシーケンスを代入してある。
 
 * sbt を起動し、 runMain SimpleSearch を実行すると、

   [info] Running SimpleSearch
   出現場所: List()

  のように表示される。

*/
 
